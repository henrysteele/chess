const highlightStyles = document.createElement("style");
document.head.append(highlightStyles);
const whiteSquareGrey = "#a9a9a9";
const blackSquareGrey = "#696969";

function removeGreySquares() {
  highlightStyles.textContent = "";
}

function greySquare(square) {
  const highlightColor =
    square.charCodeAt(0) % 2 ^ square.charCodeAt(1) % 2
      ? whiteSquareGrey
      : blackSquareGrey;

  highlightStyles.textContent += `
    chess-board::part(${square}) {
      background-color: ${highlightColor};
    }
  `;
}

board.addEventListener("drag-start", (e) => {
  const { source, piece, position, orientation } = e.detail;

  // do not pick up pieces if the game is over
  if (game.game_over()) {
    e.preventDefault();
    return;
  }

  // only pick up pieces for White
  if (piece.search("b") > -1) {
    e.preventDefault();
    return;
  }
});

document.addEventListener("keyup", function (event) {
  if (event.code == "Escape") {
    game.undo();
    board.setPosition(game.fen());
  }
});

removeGreySquares();

board.addEventListener("drop", (e) => {
  const { source, target, setAction } = e.detail;

  // see if the move is legal
  const move = game.move({
    from: source,
    to: target,
    promotion: 'q' // NOTE: always promote to a queen for example simplicity

  });

  // illegal move
   if (move === null) {
    setAction('snapback');
  }

  board.addEventListener('mouseover-square', (e) => {
  const {square, piece} = e.detail;

  // get list of possible moves for this square
  const moves = game.moves({
    square: square,
    verbose: true
  });

  // exit if there are no moves available for this square
  if (moves.length === 0) {
    return;
  }

  // highlight the square they moused over
  greySquare(square);

  // highlight the possible squares for this piece
  for (const move of moves) {
    greySquare(move.to);
  }
});

board.addEventListener('mouseout-square', (e) => {
  removeGreySquares();
});

board.addEventListener('snap-end', (e) => {
  board.setPosition(game.fen())
});

  // make random legal move for black
  window.setTimeout(makeSmartMove, 250);
};

function sortByLength(array) {
  return array.sort((x, y) => x.length - y.length);
}

function makeSmartMove() {
  let possibleMoves = game.moves();

  // game over
  if (possibleMoves.length === 0) {
    return;
  }

  const sorted = sortByLength(possibleMoves);
  if (sorted[0].length > 3) {
    game.move(sorted[0]);
    board.setPosition(game.fen());
    return;
  }

  const sophisticatedMoves = possibleMoves.filter((item) => item.length > 2);
  if (sophisticatedMoves.length > 0) possibleMoves = sophisticatedMoves;

  const randomIdx = Math.floor(Math.random() * possibleMoves.length);
  game.move(possibleMoves[randomIdx]);
  board.setPosition(game.fen());
}

// update the board position after the piece snap
// for castling, en passant, pawn promotion
board.addEventListener("snap-end", (e) => {
  board.setPosition(game.fen());
});
